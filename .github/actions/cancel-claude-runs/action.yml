name: "Cancel Claude Runs"
description: "Cancel queued/in_progress workflow runs for a given workflow, matching PR number / branch / sha."

inputs:
  workflow_id:
    description: "Workflow file name or ID to cancel (e.g. claude-review.yml)"
    required: true
  pr_number:
    description: "PR number (string/number). Optional but recommended."
    required: false
    default: ""
  head_ref:
    description: "Head branch name. Optional."
    required: false
    default: ""
  head_sha:
    description: "Head sha. Optional."
    required: false
    default: ""
  max_runs:
    description: "Max runs to scan (1-100)."
    required: false
    default: "50"

runs:
  using: "composite"
  steps:
    - uses: actions/github-script@v7
      with:
        script: |
          const workflowId = String(core.getInput('workflow_id')).trim();
          const prNumber = String(core.getInput('pr_number') || '').trim();
          const headRef = String(core.getInput('head_ref') || '').trim();
          const headSha = String(core.getInput('head_sha') || '').trim();
          const maxRuns = Math.min(Math.max(Number(core.getInput('max_runs') || '50'), 1), 100);

          if (!workflowId) {
            core.warning('workflow_id is empty. Nothing to cancel.');
            return;
          }

          // List workflow runs via request (stable across octokit variants)
          async function listRuns() {
            const res = await github.request(
              'GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs',
              {
                owner: context.repo.owner,
                repo: context.repo.repo,
                workflow_id: workflowId,
                per_page: maxRuns,
              }
            );
            return res.data?.workflow_runs || [];
          }

          function matches(run) {
            // Only cancel queued / in_progress
            if (!['queued', 'in_progress'].includes(run.status)) return false;

            // Prefer explicit PR match when available
            if (prNumber) {
              const prs = run.pull_requests || [];
              if (prs.some(p => String(p.number) === prNumber)) return true;

              const title = String(run.display_title || '').toLowerCase();
              if (title.includes(`pr #${prNumber}`)) return true;
            }

            if (headRef && String(run.head_branch || '') === headRef) return true;
            if (headSha && String(run.head_sha || '') === headSha) return true;

            return false;
          }

          const runs = await listRuns();
          const targets = runs.filter(matches);

          if (targets.length === 0) {
            core.info(`No running runs to cancel for workflow=${workflowId} pr=${prNumber} ref=${headRef} sha=${headSha}`);
            return;
          }

          core.info(`Canceling ${targets.length} run(s) for workflow=${workflowId}...`);

          for (const r of targets) {
            try {
              await github.request(
                'POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel',
                {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  run_id: r.id,
                }
              );
              core.info(`Canceled run id=${r.id} status=${r.status} head_branch=${r.head_branch} head_sha=${r.head_sha}`);
            } catch (e) {
              core.warning(`Failed to cancel run id=${r.id}: ${e.message}`);
            }
          }
